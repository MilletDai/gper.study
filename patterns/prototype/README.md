# 应用场景
  * 类初始化消耗较多资源（数据、硬件等）
  * new产生的一个对象需要非常繁琐的（数据准备、访问权限）过程
  * 构造函数比较复杂
  * 循环体中产生大量对象，可读性下降
  * 为调用者提供对象，且各个调用者都需要修改其值
  * 一般与工厂方法模式组合使用
# 实现方式
  * 实现`Cloneable`接口的`clone()`方法
  * 序列化、反序列化，实现`deepClone()`
# 缺点
  * 必须具备`clone`方法
  * 对克隆复杂对象或对克隆出的对象进行复杂改造时，易带来风险。
  * 深克隆和浅克隆运用得当
  * 破坏单例
# 关于`Cloneable`
  * `transient`
    > 被此关键字修饰的变量不会被序列化
  * `final`
    > 被此关键字修饰的变量不可被重新赋值，与`clone()`冲突
  * 调用`super.clone()`即`Object.clone()` 时不会执行`constructor`
